
\appendix
\chapter{Intermediate Codes} \label{appendix:intermediate_codes}
\begin{figure}[H]
    \centering
    \captionsetup{justification=centering}
    \begin{subfigure}{\textwidth}
        \centering
        \begin{minted}[linenos=true, autogobble, frame=lines, framesep=2mm, fontsize=\scriptsize]{c++}
            for(double i = 2; i < 9; i += dT_out){
                t_dum += i;
                double enow = gecis(r_pos, vel, Et, t_dum);
                if( enow > maxE ){
                  maxE = enow;
                  t_opt = i;
                }
                t_dum = t;
            }
        \end{minted}
    \end{subfigure} 
    \\
    \begin{subfigure}{\textwidth}
        \centering
        \begin{minted}[linenos=true, autogobble, frame=lines, framesep=2mm,  fontsize=\scriptsize]{c++}
            double gecis(double r_pos, double vel, double Et, double &t){
                for(; r_pos >= -R2 && r_pos <= R2 ; t+=dT){
                    vel = c*sqrt(Et*Et-E0*E0)/Et;
                    double RelBeta  = vel/c;
                    double RelGamma = 1.0 / sqrt(1.0-RelBeta*RelBeta);
                
                    double ef=Eradial(r_pos*1000,t,RFphase*deg_to_rad);
                
                    double acc=ef*1E6*eQMratio/(RelGamma*RelGamma*RelGamma); 
                
                    r_pos = r_pos + vel * dT*ns + 1/2*acc*(dT*ns)*(dT*ns);
                    vel=vel+acc*dT*ns;
                    RelBeta  = vel/c;
                    RelGamma = 1.0 / sqrt(1.0-RelBeta*RelBeta);
                    Et=RelGamma*E0; 
                }
                return Et;
            }
        \end{minted}
    \end{subfigure}
    \caption{$L_{out}$ Optimization For Single \e}
    \label{fig:lout_opt_single_e}
\end{figure}

\begin{figure}[H]
        \centering
        \captionsetup{justification=centering}
        \begin{minted}[linenos=true, autogobble, frame=lines, framesep=2mm, fontsize=\scriptsize]{c++}
            int phase_opt(const vector<double>& Louts, int phase_sweep_range){
                double minrms = 1;
                int opt_phase;
                for(int RFphase = -phase_sweep_range; RFphase <= phase_sweep_range; RFphase++){
                    Bunch bunch1(RFphase);
                    double t1 = 0;
                    bunch1.bunch_gecis_t(t1);
                    bunch1.reset_pos();
            
                    for(int i = 0; i < Louts.size(); i++){
                        bunch1.bunch_gecis_d(Louts[i]);
                        bunch1.reset_pos();
                    }
                        
                    if( bunch1.E_rms() < minrms ){
                        minrms = bunch1.E_rms();
                        opt_phase = RFphase;
                    }
                }
                return opt_phase;
            }
        \end{minted}
    \caption{$\phi_{lag}$ Optimization For Initial Bunch Design}
    \label{fig:phlag_opt_n_pass}
\end{figure}

\begin{figure}[H]
    \captionsetup[subfigure]{justification=centering}
    \captionsetup{justification=centering}
    \begin{subfigure}{\textwidth}
        \begin{minted}[linenos=true, autogobble, frame=lines, framesep=2mm, fontsize=\scriptsize]{c++}
            double vector3d::operator* (const vector3d& other){
                double dot = 0;
                dot += this->x * other.x;
                dot += this->y * other.y;
                dot += this->z * other.z;
                return dot;
            }
        \end{minted}
    \end{subfigure}

    \begin{subfigure}{\textwidth}
        \begin{minted}[linenos=true, autogobble, frame=lines, framesep=2mm, fontsize=\scriptsize]{c++}
            vector3d vector3d::operator% (const vector3d& other){
                double x_ = (this->y * other.z) - (this->z * other.y);
                double y_ = (this->z * other.x) - (this->x * other.z);
                double z_ = (this->x * other.y) - (this->y * other.x);
                vector3d crossed(x_, y_, z_);
                return crossed;
            }
        \end{minted}
    \end{subfigure}
    \caption{* and \% operators of \textit{vector3d} class}
    \label{fig:vector3d_dot_cross_product}
\end{figure}

\begin{figure}[H]
    \centering
    \captionsetup{justification=centering}
    \begin{minted}[linenos=true, autogobble, frame=lines, framesep=2mm, fontsize=\scriptsize]{c++}
        bool isInsideHalfSphere(vector3d e_position, double r, vector3d hs_position){
            vector3d relative = e_position - hs_position;       
            // r/5 can be changed, use this for now                                
            if ( relative.magnitude() <= r && relative * hs_position.direction() >= -r/5){      
                return true;                                                                 
            }
            return false;
        }
    \end{minted}
\caption{Logic of is \e inside the shape of magnet}
\label{fig:is_inside_halfsphere}
\end{figure}

\begin{figure}[H]
    \centering
    \captionsetup{justification=centering}
    \begin{minted}[linenos=true, autogobble, frame=lines, framesep=2mm, fontsize=\scriptsize]{c++}
        vector3d Electron2D::interactB_RK(const MagneticField& B, double time_interval){
            if (B.isInside(pos) == -1){
                return vector3d(0,0,0);
            }
            Electron2D e_dummy;
            e_dummy.Et = Et;
            e_dummy.pos = pos;
            e_dummy.vel = vel;
            double time_halved = time_interval*0.5;
            // get k1                                       
            vector3d F_m = (e_dummy.vel % B.getField(pos))*eQMratio;                                       
            vector3d k1 = F_m * e_dummy.gamma_inv();     
            // get k2
            e_dummy.move(time_halved);
            e_dummy.accelerate(k1, time_halved);                                              
            F_m = (e_dummy.vel % B.getField(pos))*eQMratio;                                               
            vector3d k2 = F_m * e_dummy.gamma_inv();    
            // get k3
            e_dummy.vel = vel;
            e_dummy.accelerate(k2, time_halved);
            vector3d k3 = F_m * e_dummy.gamma_inv();   
            // get k4
            e_dummy.vel = vel;
            e_dummy.move(time_halved);
            e_dummy.accelerate(k3, time_interval);                                           
            F_m = (e_dummy.vel % B.getField(pos))*eQMratio;  
            vector3d k4 = F_m * e_dummy.gamma_inv();
        
            return (k1 + k2*2 + k3*2 + k4)/6;
        }
    \end{minted}
\caption{RK4-1 implemenation of \e-$\vecthreeBF{B}$}
\label{fig:rk1_B}
\end{figure}
\begin{figure}[H]
    \centering
    \captionsetup{justification=centering}
    \begin{minted}[linenos=true, autogobble, frame=lines, framesep=2mm, fontsize=\scriptsize]{c++}
        void Electron2D::interactRK_ActorE(const RFField& E, const MagneticField& B, double time_interval){
            vector3d run_kut_E = interactE_RK(E, time_interval);
            vector3d run_kut_B = interactB_RK(B, time_interval);
        
            vector3d acc = run_kut_E + run_kut_B;
            
            move(acc, time_interval/2);
            accelerate(acc, time_interval);
            move(acc, time_interval/2);
        }
    \end{minted}
\caption{RK4-1 implemenation of \eEM}
\label{fig:rk1_EM}
\end{figure}

\begin{figure}[H]
    \centering
    \captionsetup{justification=centering}
    \begin{minted}[linenos=true, autogobble, frame=lines, framesep=2mm, fontsize=\tiny]{c++}
        void Electron2D::interactRK(RFField& E, MagneticField& B, const double time, double time_interval){
            Electron2D e_dummy;
            e_dummy.Et = Et;
            e_dummy.pos = pos;
            e_dummy.vel = vel;
    
            // Calculate k1
            vector3d acc_E = E.actOn(e_dummy);
            vector3d acc_B = B.actOn(e_dummy);
            vector3d acc = acc_E + acc_B;
            e_dummy.move(time_interval);
            e_dummy.accelerate(acc, time_interval);
            vector3d pos_k1 = e_dummy.pos, vel_k1 = e_dummy.vel;
    
            // Calculate k2
            e_dummy.pos = (pos + pos_k1)*0.5;
            e_dummy.vel = (vel + vel_k1)*0.5;
            e_dummy.Et = e_dummy.gamma()*E0;
            E.update(time + time_interval*0.5);
    
            acc_E = E.actOn(e_dummy);
            acc_B = B.actOn(e_dummy);
            acc = acc_E + acc_B;
            e_dummy.move(time_interval);
            e_dummy.accelerate(acc, time_interval);
            vector3d pos_k2 = e_dummy.pos, vel_k2 = e_dummy.vel;
    
            // Calculate k3
            e_dummy.pos = (pos + pos_k2)*0.5;
            e_dummy.vel = (vel + vel_k2)*0.5;
            e_dummy.Et = e_dummy.gamma()*E0;
            E.update(time + time_interval*0.5);

            acc_E = E.actOn(e_dummy);
            acc_B = B.actOn(e_dummy);
            acc = acc_E + acc_B;
            e_dummy.move(time_interval);
            e_dummy.accelerate(acc, time_interval);
            vector3d pos_k3 = e_dummy.pos, vel_k3 = e_dummy.vel;
    
            // Calculate k4
            E.update(time + time_interval);

            acc_E = E.actOn(e_dummy);
            acc_B = B.actOn(e_dummy);
            acc = acc_E + acc_B;
            e_dummy.move(time_interval);
            e_dummy.accelerate(acc, time_interval);
            vector3d pos_k4 = e_dummy.pos, vel_k4 = e_dummy.vel;
    
            E.update(time);
            pos = (pos_k1 + pos_k2*2 + pos_k3*2 + pos_k4)/6;
            vel = (vel_k1 + vel_k2*2 + vel_k3*2 + vel_k4)/6;
            Et = gamma()*E0;
    }
    \end{minted}
\caption{RK4-2 implemenation of \eEM}
\label{fig:rk2_EM}
\end{figure}

\begin{figure}[H]
    \centering
    \captionsetup{justification=centering}
    \begin{minted}[linenos=true, autogobble, frame=lines, framesep=2mm, fontsize=\tiny]{c++}
        void RhodotronSimulator::_runMT(){
            gun.fireAllWithFireTimesMT();
        
            MTEngine.setupPool(time_interval, start_time, end_time, gun, E_field, B_field, gun.thread_bunchs);
        
            STEPS_TAKEN = 0;
            simulation_time = start_time;
            while (simulation_time < end_time + time_interval ){
                if (STEPS_TAKEN % log_interval() == 0){
                    E_field.update(simulation_time);
                    logEfield(simulation_time, simulation_time + time_interval > end_time);
                    notifyUI(MTEngine.getAverageTime());
                }
                simulation_time+=time_interval;
                STEPS_TAKEN++;
            }
            bool end = false;
            while (!end){
                double time = MTEngine.getAverageTime();
                notifyUI(time);
                if ( time >= end_time ){
                    end = true;
                }
                this_thread::yield();
            }
            MTEngine.join();
            
        }
    \end{minted}
    \caption{Multithreading main-thread logic.}
    \label{fig:_runMT}
\end{figure}

\begin{figure}[H]
    \centering
    \captionsetup{justification=centering}
    \begin{minted}[linenos=true, autogobble, frame=lines, framesep=2mm, fontsize=\tiny]{c++}
        void Gun::fireAllWithFireTimesMT(){
            std::random_device rd;
            std::mt19937 e2(rd());
            std::normal_distribution<double> Edist(Ein, sEin);
    
            for(_fired_bunch= 0; _fired_bunch < bunch_count; _fired_bunch++){
                for(_fired_e_in_current_bunch= 0; _fired_e_in_current_bunch < e_per_bunch; _fired_e_in_current_bunch++){
    
                    double E = (sEin == 0 ) ? Ein : Edist(e2);
    
                    double fire_time = (ns_between_each_electron_fire * _fired_e_in_current_bunch) + _fired_bunch*gun_period;
    
                    auto burrowed_e = bunchs[_fired_bunch].AddElectronGiveAddress(E, gunpos, gundir, fire_time);
    
                    int thread_index = (_fired_e_in_current_bunch + _fired_bunch*e_per_bunch)%thread_bunchs.size();
    
                    thread_bunchs[thread_index]->push_back(burrowed_e);
                }
            }
        }
    \end{minted}
    \caption{Multithreading electron assign logic.}
    \label{fig:fireAllWithFireTimesMT}
\end{figure}

\begin{figure}[H]
    \centering
    \captionsetup{justification=centering}
    \begin{minted}[linenos=true, autogobble, frame=lines, framesep=2mm, fontsize=\tiny]{c++}
        void MultiThreadEngine::setupPool( double _time_interval, double _start_time, double _end_time, Gun& gun, 
            CoaxialRFField& RF, MagneticField& B, vector<shared_ptr<vector<shared_ptr<Electron2D>>>>& e_list){
            threads.reserve(thread_count);
        
            for(int i = 0; i < thread_count && i == threads.size(); i++){
        
                child_notifier_mutexes.push_back(make_shared<mutex>());
                child_times.push_back(make_shared<double>());
                
                auto _E = RF.Copy();
                auto _B = B.LightWeightCopy();
                double time_between_fires = thread_count*gun.getGunActiveTime()/gun.getElectronsPerBunch();
                double first_fire_time = i*gun.getGunActiveTime()/gun.getElectronsPerBunch();
                ThreadArguments thread_arguments(i, _time_interval, _start_time, _end_time, &gun, _E, _B, e_list[i], first_fire_time, time_between_fires);
                thread_arguments.parent_notifier_mutex = child_notifier_mutexes[i];
                thread_arguments.current_thread_time = child_times[i];
                threads.push_back(thread(threadLoop, thread_arguments));
            }
        }
    \end{minted}
    \caption{Multithreading worker-threads setup logic.}
    \label{fig:setupPool}
\end{figure}

\begin{figure}[H]
    \centering
    \captionsetup{justification=centering}
    \begin{minted}[linenos=true, autogobble, frame=lines, framesep=2mm, fontsize=\tiny]{c++}
        void threadLoop(ThreadArguments thread_arguments){
            uint64_t count = 0;
        
            double sim_time = thread_arguments.start_time;
        
            while(sim_time < thread_arguments.end_time + thread_arguments.time_interval){
                thread_arguments.E->update(sim_time);
                thread_arguments.i_args.time = sim_time;
                
                if ( count % (unsigned long)(0.1/thread_arguments.time_interval) == 0){
                    saveElectronInfoForSingleThread(thread_arguments.i_args);
                    // Notifiy the main thread
                    if(thread_arguments.parent_notifier_mutex->try_lock()){
                        *thread_arguments.current_thread_time = sim_time;
                        thread_arguments.parent_notifier_mutex->unlock();
                    }
                }
        
                interactForSingleThread(thread_arguments.i_args);
                // save electron info here
                sim_time+= thread_arguments.time_interval;
                count++;
            }
            thread_arguments.parent_notifier_mutex->lock();
            *thread_arguments.current_thread_time = sim_time;
            thread_arguments.parent_notifier_mutex->unlock();
        }
    \end{minted}
    \caption{Multithreading worker-thread logic.}
    \label{fig:threadLoop}
\end{figure}

\begin{figure}[H]
    \centering
    \captionsetup{justification=centering}
    \begin{minted}[linenos=true, autogobble, frame=lines, framesep=2mm, fontsize=\tiny]{c++}
        void UIThreadWork(UIThreadArgs args){
            int UI_WORK_PIECE = SIM_WORK_MASK;
            if ( !args.isService ) {
                UI_WORK_PIECE = 50;
            }
        
            double piece = (args.end_time - args.start_time)/UI_WORK_PIECE;
        
            if ( !args.isService ) {
                std::string sim_running_msg = "...Simulation is running...";
                for(int i = 0; i < 26 - sim_running_msg.size()/2 ; i++){
                    std::cout << " ";
                }
                std::cout << sim_running_msg <<"\n";
            }
        
            args.ui_mutex->lock();
            double simtime = *(args.simulation_time);
            args.ui_mutex->unlock();
        
            if ( !args.isService ) {
                std::cout << "V";
                for(int i = 0; i < 51; i++){
                    std::cout << "_";
                }
                std::cout << "V\n[" << std::flush;
            }
        
            int count = 0;
            bool running = true;
            while(running && (simtime < args.end_time || count < UI_WORK_PIECE )){
                if( simtime > count * piece ){
                    if ( !args.isService ) {
                        std::cout << "#" << std::flush;
                    }
                    count++;
                    args.state_mutex->lock();
                    running = *args.state_ptr & SIM_RUNNING;
                    *args.state_ptr = (*args.state_ptr & ~SIM_WORK_MASK) | (count & SIM_WORK_MASK);
                    if (args.isService) write(args._fd, args.state_ptr, SIGNAL_SIZE);
                    args.state_mutex->unlock();
                }
                std::this_thread::sleep_for(std::chrono::milliseconds(25));
                args.ui_mutex->lock();
                simtime = *(args.simulation_time);
                args.ui_mutex->unlock();
        
            }
            if ( !args.isService ) {
                std::cout << "#]\n\n" << std::flush;
                std::cout << "     ...Simulation is finished successfully...\n\n" << std::flush;
            }
        
            args.state_mutex->lock();
            *args.state_ptr |= SIM_RENDERING;
            if ( args.isService ) write(args._fd, args.state_ptr, SIGNAL_SIZE);
            args.state_mutex->unlock();
        }
    \end{minted}
    \caption{UI-Console handler thread logic.}
    \label{fig:ui_thread}
\end{figure}


\begin{figure}[H]
    \centering
    \captionsetup{justification=centering}
    \begin{minted}[linenos=true, autogobble, frame=lines, framesep=2mm, fontsize=\tiny]{c++}
        class Electron{
            std::vector<ElectronLog> log;
            uint64_t index;
            double Et;
            vector3d pos;
            vector3d vel;
            double fire_time;
        public:
            Electron();
            Electron(double Ein, vector3d position, vector3d direction, double _fire_time = 0);
            ~Electron();

            void setEin(double E_in);
            void print_electron_info();

            void move(double dt);
            void move(const vector3d& acc, double dt);
            void move(const vector3d& acc, const vector3d& jerk, double dt);
            void accelerate(const vector3d& acc, double dt);
            void accelerate(const vector3d& acc, const vector3d& jerk, double dt);
            
            void interactLF(RFField& E, MagneticField& B, double time_interval);
            void interactRK(RFField& E, MagneticField& B, double time_interval);
            void interactRK(RFField& E, MagneticField& B, const double time, double time_interval);
            void interactRK_ActorE(const RFField& E, const MagneticField& B, double time_interval);

            vector3d interactE_RK(const RFField& E, double time_interval);
            vector3d interactB_RK(const MagneticField& B, double time_interval);

            void saveInfo(double t);
            void setLogSize(size_t size);
            void loge(DataStorage& path);
            const vector<ElectronLog>& getLog();

            double vel();
            double beta();
            double beta2();
            double gamma();
            double gamma_inv();
        };
    \end{minted}
    \caption{Electron class definition}
    \label{fig:e_class}
\end{figure}

\begin{figure}[H]
    \centering
    \captionsetup{justification=centering}
    \begin{minted}[linenos=true, autogobble, frame=lines, framesep=2mm, fontsize=\tiny]{c++}
        class Bunch{
        private:
            int e_count = 0;
            int index_fastest = 0;
            double max_energy = 0;
            double entry_time = 0;
            double E_in = 0.04;

            vector<Bunch> subBunchs;
            vector<shared_ptr<Electron>> e;
        public:
            Bunch(unsigned int num_of_electrons, double Ein, vector3d gunpos, vector3d gundir, double gun_ns);
            Bunch();
            ~Bunch();

            void saveInfo(double time);

            Electron& getFastest();

            void AddElectron(double Ein, const vector3d& gunpos, const vector3d& gundir, double fire_time);

            shared_ptr<Electron> AddElectronGiveAddress(double Ein, const vector3d& gunpos, const vector3d& gundir, double fire_time);

            void setEntryTime(double entry_time);
            void setEin(double E_in);
            void setNSLen(double len);

            uint32_t get_e_count();
            double getEin();
            double E_ave();
            double E_rms();

            void interact(RFField& E, MagneticField& B, const double time, double time_interval);

            void divide(unsigned int num);
            void concat();
            Bunch& subBunch(unsigned int index);
            vector<Bunch*> subBunchPtr();

            void reset();

            void print_bunch_info();
            void print_summary();

            void logPaths(vector<DataStorage>& pathStorage, std::string header);
        };
    \end{minted}
    \caption{Bunch class definition}
    \label{fig:bunch_class}
\end{figure}

\begin{figure}[H]
    \centering
    \captionsetup{justification=centering}
    \begin{minted}[linenos=true, autogobble, frame=lines, framesep=2mm, fontsize=\tiny]{c++}
        class Gun{
            double Ein;
            double sEin;
            double gun_period;
            double gun_active_time;
            double ns_between_each_electron_fire;

            vector3d gunpos;
            vector3d gundir = vector3d(1,0,0);

            uint64_t bunch_count = 0;
            uint64_t e_per_bunch = 1;

            uint32_t _fired_bunch = 0;
            uint32_t _fired_e_in_current_bunch = 0;
            bool _firing = false;

            bool _mt_enabled = false;
            uint32_t _child_thread_count = 0;

            vector<Bunch> bunchs;

            mutex _gun_mutex; 
            vector<shared_ptr<vector<shared_ptr<Electron>>>> thread_bunchs;

            void setNSLen(double len);
        public:
            Gun();
            Gun(double Ein, double gun_active_time, double pulse_interval, vector3d gunpos);
            ~Gun();
            void interact(RFField& E, MagneticField& B, const double time, double time_interval);

            void fireIfActive(double time);
            void fireAllWithFireTimesMT();
            
            void addBunch(unsigned int num_of_electrons, double Ein);

            void setGunActiveTime(double gt);
            double getGunActiveTime(){return gun_active_time;}
            void setGunInterval(double guninterval);
            void setGunPos(vector3d gun_pos);
            void setGunDir(vector3d gun_dir);
            void setEin(double Ein) ;
            void setEinStd(double EinStd) ;
            void setNumberOfElectrons(uint64_t e_num);
            void getElectronsPerBunch(){return e_per_bunch;}
            void setNumberOfBunchs(uint64_t b_num);
            void enableMT(uint32_t thread_count);
            
            void saveInfo(double time);
            void logPaths(vector<vector<DataStorage> >& pathsStorage, std::string pathsPath, std::string header);
        };
    \end{minted}
    \caption{Gun class definition}
    \label{fig:gun_class}
\end{figure}

\begin{figure}[H]
    \centering
    \captionsetup{justification=centering}
    \begin{minted}[linenos=true, autogobble, frame=lines, framesep=2mm, fontsize=\tiny]{c++}
        class Simulator{        // E in MV/m,   En in MeV,   B in T,    t in ns
        protected:
            Gun gun;
            double Emax; double freq = 107.5; double phase_lag = 0; 
            DataStorage EfieldStorage; DataStorage BfieldStorage;
            vector<vector<DataStorage>> pathsStorage;
            std::string configPath;
            std::string pathsPath;
            std::string EfieldLogHeader;
            std::string BfieldLogHeader;
            std::string eLogHeader;

            double simulation_time = 0;
            double dummy_time = 0;
            double start_time = 0;
            double end_time = 45;   
            double time_interval = 0.0001;
            uint64_t STEPS_TAKEN = 0;
            double GUN_ACTIVE_TIME = 1;         
            double GUN_PERIOD = 9.3;
            uint64_t NUM_OF_ELECTRONS = 1;
            uint64_t NUM_OF_BUNCHS = 1;
            double Ein = 0.04;
            double EinStd = 0;
            vector3d gunPosition;
            vector3d gunDirection = vector3d(1,0,0);

            shared_ptr<mutex> ui_mutex;
            UIHandler ui_handler;
            shared_ptr<mutex> state_mutex;
            uint8_t state = 0x0;

            MultiThreadEngine MTEngine;
            unsigned int MAX_THREAD_COUNT = 1;
            bool MULTI_THREAD = false;
        public:
            Simulator();
            ~Simulator(){}

            void enableMultiThreading(unsigned int thread_count);
            void setdT(double dT);
            void setEin(double E_in);
            void setEinStd(double Ein_Std);
            void setNumberofElectrons(uint64_t num_of_electrons);
            void setNumberofBunchs(uint64_t num_of_bunchs);
            void setStartTime(double starttime);
            void setEndTime(double end_time);
            void setGunActiveTime(double gun_ns);
            void setGunPeriod(double pi);
            void setGunPosition(vector3d pos);
            void setGunDirection(vector3d dir);
            void setRFPath(std::string path);
            void setBPath(std::string path);
            void setPathsPath(std::string path);
            void setConfigPath(std::string path);

            virtual void run();
            void openLogs();
            void closeLogs();
            virtual void getConfig(Configuration& config) = 0;
            virtual void logEfield(double time, bool) = 0;
            virtual void logBfield() = 0;
            void logPaths();
            shared_ptr<mutex> getUIMutex();
        };
    \end{minted}
    \caption{Simulator class definition}
    \label{fig:sim_class}
\end{figure}

\begin{figure}[H]
    \centering
    \captionsetup{justification=centering}
    \begin{minted}[linenos=true, autogobble, frame=lines, framesep=2mm, fontsize=\tiny]{c++}
        class RhodotronSimulator : public Simulator{
        private:
            double R1;
            double R2;
            CoaxialRFField E_field;
            MagneticField B_field;

            void _runMT();
            void _runST();
        public:
            RhodotronSimulator(double phase_lag);
            RhodotronSimulator(Configuration& config);

            void StartUIHandler();
            void StopUIHandler();
            void DeclareService(std::string pipe_name);

            void setFreq(double frequency);
            void setPhaseLag(double phase_lag);
            void setEmax(double E_max);
            void setR1(double r1);
            void setR2(double r2);
            void addMagnet(double B, double r, vector3d position);
            void addMagnet(Magnet m);
            
            void updateSimulation();
            void getConfig(Configuration& config);
            void logEfield(double time, bool end);
            void logBfield();

            void run();
            void notifyUI(double time);

            void setState(uint8_t state_);
        };
    \end{minted}
    \caption{RhodotronSimulator class definition}
    \label{fig:rhodosim_class}
\end{figure}

\begin{figure}[H]
    \captionsetup[subfigure]{justification=centering}
    \captionsetup{justification=centering}
    \begin{subfigure}{\textwidth}
        \begin{minted}[linenos=true, autogobble, frame=lines, framesep=2mm, fontsize=\tiny]{c++}
            class RFField{
            protected:
                double E;                       // MV/m
                double E_max = 0;               // MV/m
                double frequency = 107.5;       // MHz
                double phase_lag = 0;           // degree
            public:
                RFField();
                RFField(double phase_lag);
                virtual ~RFField() {}

                virtual vector3d getField(vector3d position);              
                virtual double getField(double R);
                virtual int log(DataStorage& rf, double time, bool end = false);
                vector3d actOn(Electron& e);    
                vector3d actOnAndGetRungeKuttaCoef(Electron& e, double dt);                  
                
                double getE() {return E;}
                void setEmax(double E_max) {this->E_max = E_max; update(0);}
                void setFreq(double freq){ frequency = freq;}
                void setPhaseLag(double phaselag){ phase_lag = phaselag; update(0);}
                virtual void update(double time);
            };
        \end{minted}
    \end{subfigure}

    \begin{subfigure}{\textwidth}
        \begin{minted}[linenos=true, autogobble, frame=lines, framesep=2mm, fontsize=\tiny]{c++}
            class CoaxialRFField : public RFField{
            private:
                double r1 = 0.188;                         // m
                double r2 = 0.753;                         // m
                double E_max_pos = r1;                     // m
                std::vector<CoaxialRFField*> _childs;
                double E_radial(double R) const;
            public:
                CoaxialRFField();
                CoaxialRFField(double phase_lag);
                ~CoaxialRFField() override;
                void setR1(double r1);
                void setR2(double r2);
                void setEmaxPos(double Emaxpos);   

                vector3d getField(vector3d position) const override;
                double getField(double R) const override;
                vector3d actOn(Electron& e);
                vector3d actOnAndGetRungeKuttaCoef(Electron& e, double dt);    
                void update(double time) override; 

                int log(DataStorage& rf, double time, bool end = false) override;

                std::shared_ptr<CoaxialRFField> Copy();
                void split(uint32_t amount_of_child);
                CoaxialRFField* child(uint32_t index);
            };
        \end{minted}
    \end{subfigure}
    \caption{CoaxialRFField class definition}
    \label{fig:rf_class}
\end{figure}

\chapter{Example Simulation Runs} \label{appendix:example_simulation_runs}

\begin{figure}[H]
    \centering
    \captionsetup{justification=centering}
    \begin{minted}[linenos=true, autogobble, frame=lines, framesep=2mm, fontsize=\scriptsize, style=staroffice]{c++}
        Optimal phase with the least RMS : -5

        Simulation settings : 
        ph = -5 deg, gt = 1 ns, enum = 1000
        dT = 0.001 ns, dT_out = 0.01 ns
        
        For the 1th magnet:
        Optimum out path = 0.81044 m
        Magnet guide = 0.25852 m
        Rho = 0.088477 m
        Drift time of the first electron in the bunch : 7.688 ns
        Drift time of the last electron in the bunch : 7.487 ns
        Max energy = 0.47581 MeV
        RMS = 0.0058165 MeV
        
        For the 2th magnet:
        Optimum out path = 1.0833 m
        Magnet guide = 0.37766 m
        Rho = 0.098898 m
        Drift time of the first electron in the bunch : 5.597 ns
        Drift time of the last electron in the bunch : 5.617 ns
        Max energy = 0.89172 MeV
        RMS = 0.0099018 MeV
        
        For the 3th magnet:
        Optimum out path = 1.1705 m
        Magnet guide = 0.41573 m
        Rho = 0.10223 m
        Drift time of the first electron in the bunch : 5.314 ns
        Drift time of the last electron in the bunch : 5.325 ns
        Max energy = 1.298 MeV
        RMS = 0.013879 MeV

        Electron with the most energy : 623) 1.6999 MeV,	RMS of bunch : 0.017981 MeV
        
        Total steps calculated : 12468052652
        Simulation finished in : 632050015 us     ( 632.1 s )
        
    \end{minted}
\caption{$\phi_{lag}$, $\rho$ \& $L$ optimization at \\$P=12$KW, $R_1=0.188$m, $R_2=0.753$m, $t_g=1$ns, $E_{in}=40$KeV}
\label{fig:lout_opt_1ns_Erms}
\end{figure}

\begin{figure}[H]
    \centering
    \captionsetup{justification=centering}
    \begin{minted}[linenos=true, autogobble, frame=lines, framesep=2mm, fontsize=\scriptsize, style=staroffice]{c++}
        Optimal phase with the least RMS : 0

        Simulation settings : 
        ph = 0 deg, gt = 0.8 ns, enum = 1000
        dT = 0.001 ns, dT_out = 0.01 ns
        
        For the 1th magnet:
        Optimum out path = 0.80787 m
        Magnet guide = 0.2574 m
        Rho = 0.088379 m
        Drift time of the first electron in the bunch : 7.629 ns
        Drift time of the last electron in the bunch : 7.48 ns
        Max energy = 0.47579 MeV
        RMS = 0.0038689 MeV
        
        For the 2th magnet:
        Optimum out path = 1.0833 m
        Magnet guide = 0.37765 m
        Rho = 0.098898 m
        Drift time of the first electron in the bunch : 5.589 ns
        Drift time of the last electron in the bunch : 5.605 ns
        Max energy = 0.89169 MeV
        RMS = 0.0068848 MeV
        
        For the 3th magnet:
        Optimum out path = 1.1705 m
        Magnet guide = 0.41573 m
        Rho = 0.10223 m
        Drift time of the first electron in the bunch : 5.311 ns
        Drift time of the last electron in the bunch : 5.318 ns
        Max energy = 1.298 MeV
        RMS = 0.0096887 MeV
        
        Electron with the most energy : 629) 1.6999 MeV,	RMS of bunch : 0.012318 MeV
        
        Total steps calculated : 12455378454
        Simulation finished in : 631136046 us     ( 631.1 s )        
    \end{minted}
\caption{$\phi_{lag}$ \& $\rho$ \& $L$ optimization at \\$P=12$KW, $R_1=0.188$m, $R_2=0.753$m, $t_g=0.8$ns, $E_{in}=40$KeV}
\label{fig:lout_opt_08ns_Erms}
\end{figure}

\begin{figure}[H]
    \captionsetup[subfigure]{justification=centering}
    \captionsetup{justification=centering}
    \centering
    \begin{subfigure}{0.9\textwidth}
        \centering
        \includegraphics[width=\linewidth]{./figures/rhodoSim/mag_rk_001dt.png}
        \caption*{$dt=10^{-2}$ns, $\Delta E=1.047$MeV}
    \end{subfigure}
    \begin{subfigure}{0.9\textwidth}
        \centering
        \includegraphics[width=\linewidth]{./figures/rhodoSim/mag_rk_00001dt.png}
        \caption*{$dt=10^{-4}$ns, $\Delta E=0.006$MeV}
    \end{subfigure}
    \caption{Energy gain of $1$MeV bunch in \textbf{B}=$0.1$T using RK4-2}
    \label{fig:mag_rk_render}
\end{figure}

\begin{figure}[H]
    \centering
    \captionsetup{justification=centering}
    \begin{minted}[linenos=true, autogobble, frame=lines, framesep=2mm, fontsize=\tiny, style=staroffice]{c++}
        #            Rhodotron Simulation Configuration File
        # ================================================================
        #    M.Furkan Er                                     22/09/2022   
        # ================================================================
        #
        # emax = Maximum electric field strength (MV/m)
        # ein = Energy of electrons coming out of the gun (MeV)
        # einstd = Standard deviation of energy of electrons coming out of the gun (MeV)
        # targeten = Max energy on the output gif (MeV)
        # freq = Frequency of the RF field (MHz)
        # phaselag = phase lag of the first electrons (degree)
        # starttime = time to start firing the gun (ns)
        # endtime = ns to run the simulation (ns)
        # dt = time interval to do the calculations (ns)
        # guntime = how long a gun pulse is (ns)
        # gunperiod = time between two gun pulses (ns)
        # enum = number of electrons to simulate in a bunch
        # bunchnum = number of times the gun fires
        # r1 = radius of the inner cylinder (m)
        # r2 = radius of the outer cylinder (m)
        # epath = path to store the electric field data
        # bpath = path to store the magnetic field data
        # cpath = path to store the settings
        # ppath = path to store electron data
        # multh = enable or disable multitheading
        # thcount = set the maximum thread to be used
        # magrotation = degrees of rotation to enter each magnet 
        # addmagnet = takes 3 input. (B , R, < Radial distance of center >)
        # output = output file name 
        
        
        # E FIELD CONFIGURATION 
        emax=1.170
        freq=107.3
        phaselag=10.0
        r1=0.1840
        r2=0.7380
        
        # B FIELD CONFIGURATION 
        magrotation=5.0
        
        # GUN CONFIGURATION 
        einmean=0.040
        einstd=0.0000
        targeten=2.0
        guntime=1.0
        gunperiod=9.3
        enum=50
        bunchnum=1
        
        # SIM CONFIGURATION 
        starttime=0
        endtime=10
        dt=0.0000010000
        epath=xy/rf.dat
        bpath=xy/magnet.dat
        cpath=xy/settings.dat
        ppath=xy/paths/
        multh=1
        thcount=10     
    \end{minted}
\caption{An example \textit{config.in} file.}
\label{fig:config_file}
\end{figure}

\begin{figure}[H]
    \centering
    \captionsetup{justification=centering}
    \begin{minted}[linenos=true, autogobble, frame=lines, framesep=2mm, fontsize=\scriptsize, style=staroffice]{c++}
        -- Simulation Configuration --
        Emax : 0.96     MV/m
        Freq : 107.5    MHz
        Phase Lag : -5  degree
        EndTime : 100   ns
        dT : 0.0001     ns
        guntime : 0.8   ns
        gunperiod : 9.3 ns
        enum : 100
        bunchnum : 2
        R1 : 0.188241   m
        R2 : 0.752967   m
        Magnet count :  5
        Ein : 0.04      MeV
        TargetE : 2.5   MeV
        --------------------------------
        
                     ...Simulation is running...
        V_____________________________________________________V
        [####################################                 ]
    \end{minted}
\caption{Example of console output while simulation is running.}
\label{fig:console_output_running}
\end{figure}

\chapter{Data and Graphs}\label{appendix:data_graph}

\begin{figure}[H]
    \captionsetup[subfigure]{justification=centering}
    \captionsetup{justification=centering}
    \centering
    \begin{subfigure}{0.9\textwidth}
        \centering
        \includegraphics[width=\linewidth]{./figures/analiz/lf_rk1_rk2_dt-E_3.png}
    \end{subfigure}
    
    \begin{subfigure}{0.9\textwidth}
        \centering
        \includegraphics[width=\linewidth]{./figures/analiz/lf_rk1_rk2_dt-Tsim_3.png}
    \end{subfigure}
    \caption{Comparing Leap-frog, RK4-1, RK4-2 performance on \eB interaction\\ $E_{in}=1$MeV, \textbf{B}=$0.1$T, $t_{end}=5$ns}
    \label{fig:lf_rk1_rk2_comparison}
\end{figure}

\begin{figure}[H]
    \captionsetup[subfigure]{justification=centering}
    \captionsetup{justification=centering}
    \centering
    \begin{subfigure}{0.9\textwidth}
        \centering
        \includegraphics[width=\linewidth]{./figures/analiz/staticE_lf_rk2_dt-E.png}
    \end{subfigure}
    
    \begin{subfigure}{0.9\textwidth}
        \centering
        \includegraphics[width=\linewidth]{./figures/analiz/staticE_lf_rk2_dt-Tsim.png}
    \end{subfigure}
    \caption{Comparing Leap-frog, RK4-2 performance on \eE interaction\\ $E_{in}=1$MeV, $\textbf{V}_{\parallel}$=4MV, $t_{end}=6$ns}
    \label{fig:lf_rk2_par_stat_E_comparison}
\end{figure}

\begin{table}[H]
    \centering
    \begin{tabular}{|l|l|l|l|}
    \hline
    dt(ns)       & $\Delta E_{avg}$(MeV) & $\mu T_{sim}$(s)    & $\sigma T_{sim}$(s) \\\hline
        1e-02 & 2.783228     & 0.034660  & 0.011537 \\ \hline
        1e-03 & 0.117124     & 0.115775  & 0.001071 \\ \hline
        9e-04 & 0.104552     & 0.128983  & 0.001820 \\  \hline
        8e-04 & 0.092252     & 0.143251  & 0.002585 \\ \hline
        7e-04 & 0.080144     & 0.158808  & 0.003228 \\ \hline
        6e-04 & 0.068258     & 0.182359  & 0.002426 \\\hline
        5e-04 & 0.056554     & 0.215104  & 0.002807 \\\hline
        4e-04 & 0.044931     & 0.262952  & 0.005119 \\\hline
        3e-04 & 0.033467     & 0.341552  & 0.002610 \\\hline
        2e-04 & 0.022158     & 0.501784  & 0.005709 \\\hline
        1e-04 & 0.011006     & 0.973145  & 0.005849 \\\hline
        9e-05 & 0.009899     & 1.084032  & 0.010985 \\\hline
        8e-05 & 0.008792     & 1.216145  & 0.012486 \\\hline
        7e-05 & 0.007688     & 1.387908  & 0.019031 \\\hline
        6e-05 & 0.006586     & 1.604475  & 0.011775 \\\hline
        5e-05 & 0.005485     & 1.926505  & 0.014535 \\\hline
        4e-05 & 0.004384     & 2.395898  & 0.009702 \\\hline
        3e-05 & 0.003286     & 3.178265  & 0.014099 \\\hline
        2e-05 & 0.002189     & 4.740706  & 0.022709 \\\hline
        1e-05 & 0.001094     & 9.441138  & 0.027266 \\\hline
        1e-06 & 0.000109     & 93.888320 & 0.290820 \\ \hline
    \end{tabular}
    \caption{\textit{Leap-frog} data on \\$E_{in}=1$MeV, \textbf{B}=$0.1$T, $t_{end}=5$ns}
    \label{tab:lf_mag_table}
\end{table}

\begin{table}[H]
    \centering
    \begin{tabular}{|l|l|l|l|}
    \hline
    dt(ns)       & $\Delta E_{avg}$(MeV) & $\mu T_{sim}$(s)    & $\sigma T_{sim}$(s) \\\hline
        1e-02 & 1.047130     & 0.048943   & 0.011642 \\\hline
        1e-03 & 0.066912     & 0.239299   & 0.003483 \\\hline
        9e-04 & 0.059899     & 0.268007   & 0.004530 \\\hline
        8e-04 & 0.053028     & 0.296154   & 0.004146 \\\hline
        7e-04 & 0.046183     & 0.333123   & 0.004259 \\\hline
        6e-04 & 0.039452     & 0.384046   & 0.002458 \\\hline
        5e-04 & 0.032734     & 0.456387   & 0.003888 \\\hline
        4e-04 & 0.026072     & 0.563011   & 0.004803 \\\hline
        3e-04 & 0.019474     & 0.742440   & 0.006169 \\\hline
        2e-04 & 0.012926     & 1.103559   & 0.007649 \\\hline
        1e-04 & 0.006437     & 2.178779   & 0.009733 \\\hline
        9e-05 & 0.005791     & 2.411302   & 0.012266 \\\hline
        8e-05 & 0.005145     & 2.704117   & 0.012683 \\\hline
        7e-05 & 0.004500     & 3.078304   & 0.013281 \\\hline
        6e-05 & 0.003856     & 3.589154   & 0.014472 \\\hline
        5e-05 & 0.003212     & 4.297561   & 0.009546 \\\hline
        4e-05 & 0.002568     & 5.369322   & 0.012127 \\\hline
        3e-05 & 0.001925     & 7.136687   & 0.007845 \\\hline
        2e-05 & 0.001283     & 10.679166  & 0.012126 \\\hline
        1e-05 & 0.000641     & 21.325229  & 0.011661 \\\hline
        1e-06 & 0.000064     & 212.824121 & 0.040967 \\\hline
    \end{tabular}
    \caption{\textit{RK4-2} data on \\$E_{in}=1$MeV, \textbf{B}=$0.1$T, $t_{end}=5$ns}
    \label{tab:rk2_mag_table}
\end{table}

\begin{table}[H]
    \centering
    \begin{tabular}{|l|l|l|l|}
    \hline
    dt(ns)       & $\Delta E_{avg}$(MeV) & $\mu T_{sim}$(s)    & $\sigma T_{sim}$(s) \\\hline
    5.00E-02 & 0.114422     & 0.028398 & 0.009294 \\\hline
    1.00E-02 & 0.019233     & 0.036245 & 0.002182 \\\hline
    1.00E-03 & 0.002141     & 0.147979 & 0.00125  \\\hline
    9.00E-04 & 0.001749     & 0.172161 & 0.00794  \\\hline
    8.00E-04 & 0.001516     & 0.184629 & 0.004359 \\\hline
    7.00E-04 & 0.00152      & 0.20445  & 0.001919 \\\hline
    6.00E-04 & 0.001049     & 0.234947 & 0.004416 \\\hline
    5.00E-04 & 0.000974     & 0.278938 & 0.010969 \\\hline
    4.00E-04 & 0.0009       & 0.336847 & 0.003028 \\\hline
    3.00E-04 & 0.000587     & 0.441771 & 0.005859 \\\hline
    2.00E-04 & 0.000433     & 0.652066 & 0.006637 \\\hline
    1.00E-04 & 0.0002       & 1.280059 & 0.016027 \\\hline
    9.00E-05 & 0.000145     & 1.41908  & 0.013122 \\\hline
    8.00E-05 & 0.000153     & 1.592492 & 0.011332 \\\hline
    7.00E-05 & 0.000162     & 1.806561 & 0.009931 \\\hline
    6.00E-05 & 0.000123     & 2.103571 & 0.011143 \\\hline
    5.00E-05 & 0.000084     & 2.515006 & 0.01393  \\\hline
    4.00E-05 & 0.000092     & 3.140471 & 0.014138 \\\hline
    3.00E-05 & 0.000053     & 4.158715 & 0.009474 \\\hline
    2.00E-05 & 0.000045     & 6.231734 & 0.015236 \\\hline
    1.00E-05 & 0.000022     & 12.39871 & 0.039575 \\\hline
    1.00E-06 & 0.000003     & 123.318  & 0.299559 \\\hline
    \end{tabular}
    \caption{\textit{LF} data on \\$E_{in}=1$MeV, $\vecthreeBF{E}=(-2.65616, 0, 0)$ MV/m, $t_{end}=6$ns}
    \label{tab:lf_statE_table}
\end{table}

\begin{table}[H]
    \centering
    \begin{tabular}{|l|l|l|l|}
    \hline
    dt(ns)       & $\Delta E_{avg}$(MeV) & $\mu T_{sim}$(s)    & $\sigma T_{sim}$(s) \\\hline
        5.00E-02 & 0.055355     & 0.031054 & 0.003281 \\\hline
        1.00E-02 & 0.009868     & 0.063656 & 0.000893 \\\hline
        1.00E-03 & 0.001141     & 0.435864 & 0.005332 \\\hline
        9.00E-04 & 0.001325     & 0.478216 & 0.00595  \\\hline
        8.00E-04 & 0.001112     & 0.533789 & 0.003897 \\\hline
        7.00E-04 & 0.000705     & 0.60586  & 0.005441 \\\hline
        6.00E-04 & 0.000687     & 0.703851 & 0.009447 \\\hline
        5.00E-04 & 0.000474     & 0.840173 & 0.00913  \\\hline
        4.00E-04 & 0.00046      & 1.039166 & 0.005874 \\\hline
        3.00E-04 & 0.000456     & 1.378822 & 0.007995 \\\hline
        2.00E-04 & 0.000207     & 2.045464 & 0.008499 \\\hline
        1.00E-04 & 0.000127     & 4.052472 & 0.014711 \\\hline
        9.00E-05 & 0.000091     & 4.500401 & 0.015404 \\\hline
        8.00E-05 & 0.000124     & 5.048922 & 0.014392 \\\hline
        7.00E-05 & 0.000062     & 5.773208 & 0.031443 \\\hline
        6.00E-05 & 0.000057     & 6.726501 & 0.020609 \\\hline
        5.00E-05 & 0.00006      & 8.045931 & 0.014246 \\\hline
        4.00E-05 & 0.000039     & 10.04809 & 0.012756 \\\hline
        3.00E-05 & 0.000045     & 13.39669 & 0.028057 \\\hline
        2.00E-05 & 0.000023     & 20.03889 & 0.006436 \\\hline
        1.00E-05 & 0.000016     & 40.0818  & 0.120627 \\\hline
        1.00E-06 & 0.000003     & 400.2421 & 0.554172 \\\hline 
    \end{tabular}
    \caption{\textit{RK4-2} data on \\$E_{in}=1$MeV, $\vecthreeBF{E}=(-2.65616, 0, 0)$ MV/m, $t_{end}=6$ns}
    \label{tab:rk2_statE_table}
\end{table}


\begin{table}[H]
    \centering
    \begin{tabular}{|l|l|l|l|}
    \hline
    dt(ns)       & $\Delta E_{avg}$(MeV) & $\mu T_{sim}$(s)    & $\sigma T_{sim}$(s) \\\hline
    5.00E-02 & 0.986005     & 0.030314 & 0.009209 \\\hline
    1.00E-02 & 0.154314     & 0.036833 & 0.004068 \\\hline
    1.00E-03 & 0.01476      & 0.131783 & 0.002352 \\\hline
    9.00E-04 & 0.013618     & 0.150984 & 0.005618 \\\hline
    8.00E-04 & 0.011863     & 0.161336 & 0.003117 \\\hline
    7.00E-04 & 0.010109     & 0.179693 & 0.002658 \\\hline
    6.00E-04 & 0.009277     & 0.205356 & 0.002912 \\\hline
    5.00E-04 & 0.007527     & 0.242352 & 0.003093 \\\hline
    4.00E-04 & 0.006084     & 0.294269 & 0.001551 \\\hline
    3.00E-04 & 0.00449      & 0.383982 & 0.001711 \\\hline
    2.00E-04 & 0.002897     & 0.563762 & 0.004214 \\\hline
    1.00E-04 & 0.001458     & 1.101252 & 0.008064 \\\hline
    9.00E-05 & 0.001376     & 1.229321 & 0.0089   \\\hline
    8.00E-05 & 0.001232     & 1.381441 & 0.01057  \\\hline
    7.00E-05 & 0.001027     & 1.574994 & 0.011933 \\\hline
    6.00E-05 & 0.000853     & 1.833183 & 0.006065 \\\hline
    5.00E-05 & 0.00074      & 2.184948 & 0.013416 \\\hline
    4.00E-05 & 0.000596     & 2.72503  & 0.016356 \\\hline
    3.00E-05 & 0.000467     & 3.617576 & 0.017581 \\\hline
    2.00E-05 & 0.000308     & 5.394629 & 0.027885 \\\hline
    1.00E-05 & 0.00015      & 10.75182 & 0.03301  \\\hline
    1.00E-06 & 0.000017     & 106.9198 & 0.373175 \\\hline
    \end{tabular}
    \caption{\textit{LF} data on \\$E_{in}=1$MeV, $\vecthreeBF{E}=(0, -5.31232, 0)$ MV/m, $t_{end}=6$ns}
    \label{tab:lf_statE90_table}
\end{table}

\begin{table}[H]
    \centering
    \begin{tabular}{|l|l|l|l|}
    \hline
    dt(ns)       & $\Delta E_{avg}$(MeV) & $\mu T_{sim}$(s)    & $\sigma T_{sim}$(s) \\\hline
        5.00E-02 & 0.587777     & 0.034741 & 0.012735 \\\hline
        1.00E-02 & 0.09943      & 0.059945 & 0.001318 \\\hline
        1.00E-03 & 0.009987     & 0.38199  & 0.005941 \\\hline
        9.00E-04 & 0.007946     & 0.417119 & 0.005683 \\\hline
        8.00E-04 & 0.007999     & 0.466052 & 0.006398 \\\hline
        7.00E-04 & 0.006732     & 0.525791 & 0.003782 \\\hline
        6.00E-04 & 0.005541     & 0.612876 & 0.007114 \\\hline
        5.00E-04 & 0.005022     & 0.732091 & 0.012129 \\\hline
        4.00E-04 & 0.004031     & 0.906845 & 0.012156 \\\hline
        3.00E-04 & 0.002779     & 1.199367 & 0.014536 \\\hline
        2.00E-04 & 0.001897     & 1.782653 & 0.016993 \\\hline
        1.00E-04 & 0.000895     & 3.52464  & 0.029778 \\\hline
        9.00E-05 & 0.000858     & 3.916115 & 0.041066 \\\hline
        8.00E-05 & 0.000731     & 4.409459 & 0.040828 \\\hline
        7.00E-05 & 0.00066      & 5.012686 & 0.042727 \\\hline
        6.00E-05 & 0.000561     & 5.851793 & 0.038488 \\\hline
        5.00E-05 & 0.000471     & 7.002315 & 0.046152 \\\hline
        4.00E-05 & 0.000363     & 8.747954 & 0.063936 \\\hline
        3.00E-05 & 0.000264     & 11.64305 & 0.091404 \\\hline
        2.00E-05 & 0.000184     & 17.44533 & 0.123198 \\\hline
        1.00E-05 & 0.000093     & 34.93332 & 0.391012 \\\hline
        1.00E-06 & 0.000011     & 348.494  & 3.237203 \\\hline
    \end{tabular}
    \caption{\textit{RK4-2} data on \\$E_{in}=1$MeV, $\vecthreeBF{E}=(-2.65616, 0, 0)$ MV/m, $t_{end}=6$ns}
    \label{tab:rk2_statE90_table}
\end{table}


\chapter{Supporting Figures} \label{appendix:supp}

\begin{figure}
    \centering
    \includegraphics[angle=270,origin=c, width=.98\linewidth]{./figures/teknikcizim/Rho-A1.1.00.pdf}
    \caption{Technical drawing of upper part of the cavity. \cite{sinan}}
    \label{fig:techd_up}
\end{figure}

\begin{figure}
    \centering
    \includegraphics[width=\linewidth]{./figures/rhodoSim/GUI_simulate_frame.png}
    \caption{Simulate frame of \textit{GUI}.}
    \label{fig:gui_simulate_1}
\end{figure}

\begin{figure}
    \centering
    \includegraphics[width=\linewidth]{./figures/rhodoSim/GUI_render_frame_2.png}
    \caption{Render frame of \textit{GUI}.}
    \label{fig:gui_render_2}
\end{figure}

\begin{figure}
    \centering
    \includegraphics[width=\linewidth]{./figures/rhodoSim/GUI_analyze_Et_2.png}
    \caption{Analyze frame of \textit{GUI} E(t).}
    \label{fig:gui_analyze_Et2}
\end{figure}

\begin{figure}
    \centering
    \includegraphics[width=\linewidth]{./figures/rhodoSim/GUI_sweep_running.png}
    \caption{Sweep frame of \textit{GUI} \\ $\phi_{lag}$ sweep running.}
    \label{fig:gui_sweep_running}
\end{figure}

\begin{figure}
    \centering
    \includegraphics[width=\linewidth]{./figures/rhodoSim/GUI_sweep_sR.png}
    \caption{Sweep frame of \textit{GUI} \\ $\phi_{lag}$ sweep $\sigma R$ result.}
    \label{fig:gui_sweep_sR}
\end{figure}